{
  "name": "locks",
  "version": "0.2.2",
  "description": "Mutex locks, Read/Write locks, Condition variables and Semaphores",
  "keywords": [
    "locks",
    "mutex",
    "semaphore",
    "condition",
    "rwlock",
    "synchronize",
    "synchronise",
    "synchronization",
    "synchronisation"
  ],
  "main": "index.js",
  "scripts": {
    "test": "tape test/*.js | tap-spec",
    "cover": "rm -rf .nyc_output && nyc --silent --all tape test/*.js > /dev/null 2>&1 && nyc report"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Wizcorp/locks"
  },
  "author": {
    "name": "Ron Korving",
    "email": "rkorving@wizcorp.jp"
  },
  "license": "MIT",
  "devDependencies": {
    "nyc": "^3.2.2",
    "tap-spec": "^4.1.0",
    "tape": "^4.2.2"
  },
  "readme": "# Locks\n\nLocks implements locking/synchronization mechanisms that have traditionally\nbeen used for protecting shared memory between multiple threads. JavaScript is\ninherently single threaded and does not suffer from these security and\nstability issues. However, because of its asynchronous eventy nature JavaScript\ncan still benefit from making particular operations wait for the completion of\nothers.\n\n## Installation\n\nNode.js users:\n```bash\nnpm install locks\n```\n\nComponent users:\n```bash\ncomponent install Wizcorp/locks\n```\n\n## API\n\nAccessing the locks module:\n```javascript\nvar locks = require('locks');\n```\n\nPlease note that all the examples below will also demonstrate how to unlock\neach time. But in general, this matters:\n```javascript\n// unlocking will give waiting processes a chance to get the lock and continue\nmyLock.unlock();\n```\n\n### Mutex locks\n\nMutex locks are the most basic locks which aim to prevent the simultaneous\naccess to a resource by more than one actor at a time.\n[more info](http://en.wikipedia.org/wiki/Mutual_exclusion)\n\nCreating a Mutex Lock:\n```javascript\nvar mutex = locks.createMutex();\n```\n\nWaiting to lock:\n```javascript\nmutex.lock(function () {\n\tconsole.log('We got the lock!');\n\t// do stuff\n\tmutex.unlock();\n});\n```\n\nWaiting to lock, with timeout:\n```javascript\nmutex.timedLock(5000, function (error) {\n\tif (error) {\n\t\tconsole.log('Could not get the lock within 5 seconds, so gave up');\n\t} else {\n\t\tconsole.log('We got the lock!');\n\t\t// do stuff\n\t\tmutex.unlock();\n\t}\n});\n```\n\nOptimistic attempt to lock:\n```javascript\nif (mutex.tryLock()) {\n\tconsole.log('We got the lock!');\n\t// do stuff\n\tmutex.unlock();\n} else {\n\tconsole.log('Could not get the lock at this time');\n}\n```\n\n### Read/Write locks\n\nRead/Write Locks are used to allow many actors to read from a resource, as\nlong as nothing is writing to it. That also means that only one actor may be\nwriting at any given time.\n[more info](http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock)\n\nCreating a Read/Write Lock:\n```javascript\nvar rwlock = locks.createReadWriteLock();\n```\n\nWaiting to read lock:\n```javascript\nrwlock.readLock(function () {\n\tconsole.log('We may now read from a resource!');\n\t// do stuff\n\trwlock.unlock();\n});\n```\n\nWaiting to write lock:\n```javascript\nrwlock.writeLock(function () {\n\tconsole.log('We may now write to a resource!');\n\t// do stuff\n\trwlock.unlock();\n});\n```\n\nWaiting to read lock, with timeout:\n```javascript\nrwlock.timedReadLock(5000, function (error) {\n\tif (error) {\n\t\tconsole.log('Could not get the lock within 5 seconds, so gave up');\n\t} else {\n\t\tconsole.log('We may now read from a resource!');\n\t\t// do stuff\n\t\trwlock.unlock();\n\t}\n});\n```\n\nWaiting to write lock, with timeout:\n```javascript\nrwlock.timedWriteLock(5000, function (error) {\n\tif (error) {\n\t\tconsole.log('Could not get the lock within 5 seconds, so gave up');\n\t} else {\n\t\tconsole.log('We may now write to a resource!');\n\t\t// do stuff\n\t\trwlock.unlock();\n\t}\n});\n```\n\nOptimistic attempt to read lock:\n```javascript\nif (rwlock.tryReadLock()) {\n\tconsole.log('We may now read from a resource!');\n\t// do stuff\n\trwlock.unlock();\n} else {\n\tconsole.log('Could not get the lock at this time');\n}\n```\n\nOptimistic attempt to write lock:\n```javascript\nif (rwlock.tryWriteLock()) {\n\tconsole.log('We may now write to a resource!');\n\t// do stuff\n\trwlock.unlock();\n} else {\n\tconsole.log('Could not get the lock at this time');\n}\n```\n\n### Condition variables\n\nCondition variables allow synchronization between processes based on values.\n\nCreating a Condition Variable:\n```javascript\nvar initialValue = 'hello world';\nvar cond = locks.createCondVariable(initialValue);\n```\n\nWaiting for a condition to be met:\n```javascript\ncond.wait(\n\tfunction conditionTest(value) {\n\t\treturn value.indexOf('こんにちは') !== -1;\n\t},\n\tfunction whenConditionMet() {\n\t\tconsole.log('Our welcome message is in Japanese!');\n\t}\n);\n```\n\nSetting the value on a Condition Variable:\n```javascript\ncond.set('こんにちは世界！');\n```\n\n### Semaphores\n\nSemaphores solve the problem of sharing a limited set of resources.\n[more info](http://en.wikipedia.org/wiki/Semaphore_%28programming%29)\n\nCreating a Semaphore:\n```javascript\nvar initialValue = 3;  // amount of resources available\nvar sem = locks.createSemaphore(initialValue);\n```\n\nClaiming and releasing a resource:\n```javascript\nsem.wait(function () {\n\tconsole.log('We may now access one resource!');\n\t// do stuff\n\t// release the resource\n\tsem.signal();\n});\n```\n\n## License\n\nMIT\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Wizcorp/locks/issues"
  },
  "_id": "locks@0.2.2",
  "dist": {
    "shasum": "3d8269afe5daa657cf423ee397f861848cb63a4f"
  },
  "_from": "locks@",
  "_resolved": "https://registry.npmjs.org/locks/-/locks-0.2.2.tgz"
}
